import time
import random
import rospy
import pytest
from unittest.mock import patch
from std_msgs.msg import String

import os, sys
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

'''Integration Test Suite for COGAR-Assignment-Group-E
This module contains end-to-end integration tests covering interactions
between all major subsystems: POS, OrchestrationManager, TIAGo,
NavigationSystem, PerceptionSystem, ReasoningSystem,
ManipulationSystem, OrderVerificationSystem, SpeechInterface.'''

# Import core components for integration testing
from scripts.ManipulationSystem import ManipulationSystem
from scripts.NavigationSystem import NavigationSystem
from scripts.OrchestrationManager import OrchestrationManager
from scripts.OrderVerificationSystem import OrderVerificationSystem
from scripts.PointOfSale import POS as POSModule
from scripts.Reasoning import ReasoningSystem, ReasoningController
from scripts.SpeechInterface import SpeechInterface
from scripts.TIAGo import TIAGo



# Integration Test: POS publishes orders and OrchestrationManager stores them correctly
# test_pos_to_orchestration_integration
def test_pos_to_orchestration_integration():
    """
    Verify that orders generated by POS are correctly received and stored by OrchestrationManager.
    """
    # Initialize orchestration manager and clear any existing orders
    om = OrchestrationManager()
    om.orderQueue.clear()
    om.error_messages.clear()

    # Override POS publisher to forward messages directly to orchestration manager
    published = []
    class DummyPub:
        def publish(self, msg):
            from std_msgs.msg import String as RosString
            if isinstance(msg, str):
                ros_msg = RosString(data=msg)
            else:
                ros_msg = msg
            om.order_storing(ros_msg)
            published.append(ros_msg.data)

    pos = POSModule()
    pos.publisher = DummyPub()

    # Patch random.randint to always emit an order
    with patch.object(random, 'randint', return_value=1):
        pos.order_emission(nb_loops=0)

    # Ensure one order was published and stored
    assert published, "POS did not publish any order"
    assert len(om.orderQueue) == 1, "OrchestrationManager did not store the order"

    # Validate stored order structure
    table, dish = om.orderQueue[0]
    assert isinstance(table, int) and 1 <= table <= 60
    assert dish in OrchestrationManager.list_dishes


# Integration Test: OrchestrationManager assigns orders to TIAGo and updates robot state
# test_orchestrationmanager_tiago_integration
def test_orchestrationmanager_tiago_integration():
    """
    Verify that OrchestrationManager assigns orders and TIAGo receives and updates its state correctly.
    """
    # Initialize OrchestrationManager singleton and clear state
    om = OrchestrationManager()
    om.orderQueue.clear()
    om.dictTIAGoAvailable.clear()
    om.dictTIAGoPosition.clear()

    rospy.init_node = lambda *args, **kwargs: None

    # Create TIAGo instance and override publishers to feed back into OM
    tiago = TIAGo()
    # Redirect TIAGo availability and position updates to OM
    tiago.publisher_availability = type('PubAvail', (), {'publish': lambda self, data: om.manage_availability(String(data=data))})()
    tiago.publisher_position = type('PubPos', (), {'publish': lambda self, msg: om.manage_position(msg)})()
    tiago.publisher_clearing_order = type('PubClear', (), {'publish': lambda self, data: None})()

    # Publish initial availability and position so OM knows TIAGo is available
    tiago.send_availability()
    tiago.send_position()
    assert om.dictTIAGoAvailable.get(tiago.id) == 'available'

    # Prepare an order for table 2 and dish 'Nare'
    om.orderQueue = [[2, 'Nare']]
    # Override OM publisher to send orders to TIAGo
    om.publisher_order = type('PubOrder', (), {'publish': lambda self, data: tiago.manage_order_request(String(data=data))})()

    # Assign the order
    om.assign_order()

    # After assignment, OM queue is empty and TIAGo status updated
    assert om.orderQueue == []
    assert om.dictTIAGoAvailable.get(tiago.id) == 'occupied'
    assert tiago.status == 'occupied'
    assert tiago.target_table == 2
    assert tiago.dish == 'Nare'


# Integration Test: OrderVerificationSystem works with SpeechInterface for delivery verification
# test_orderverification_and_speechinterface_integration
def test_orderverification_and_speechinterface_integration():
    """
    Verify that OrderVerificationSystem uses both perception and speech interface correctly.
    """
    # Create dummy TIAGo with a mock perception system
    class DummyTiago:
        pass

    tiago = DummyTiago()
    # Setup mock perception system
    class MockPerception:
        def verification_of_grasping_and_placement(self, mode):
            # return True for both grasping and placement
            return True
    tiago.perception_system = MockPerception()

    # Initialize OrderVerificationSystem and attach TIAGo
    ov = OrderVerificationSystem(tiago)
    # Replace speech_interface with one bound to our dummy TIAGo
    si = SpeechInterface()
    si.tiago = tiago
    # Patch serving_sentences to simulate each case

    # Case A: no customer problem
    si.serving_sentences = lambda: None
    ov.speech_interface = si
    out = ov.verify_delivery_client()
    # perception success -> first element False, no client problem -> second None
    assert out == [False, None]

    # Case B: placement succeeded, but client reports 'empty_plates'
    si.serving_sentences = lambda: 'empty_plates'
    ov.speech_interface = si
    out = ov.verify_delivery_client()
    assert out == [False, 'empty_plates']

    # Case C: physical placement fails, client has no additional complaint
    class FailPerception:
        def verification_of_grasping_and_placement(self, mode):
            return False
    tiago.perception_system = FailPerception()
    si.serving_sentences = lambda: None
    ov = OrderVerificationSystem(tiago)
    ov.speech_interface = si
    out = ov.verify_delivery_client()
    # perception failure -> first True, no client problem
    assert out == [True, None]


# Integration Test: TIAGo uses OrderVerificationSystem and SpeechInterface for empty plate handling
# test_tiago_orderverification_integration
def test_tiago_orderverification_integration():
    """
    Verify TIAGo uses OrderVerificationSystem and SpeechInterface to switch to clearing flow when client requests empty plates.
    """
    # Prevent rospy.init_node() collision in tests
    rospy.init_node = lambda *args, **kwargs: None
    tiago = TIAGo()

    # Define a mock PerceptionSystem
    class DummyPerception:
        def perception(self):
            return True
        def verification_of_grasping_and_placement(self, phase):
            # Always consider grasping/placement phases successful
            return True

    tiago.perception_system = DummyPerception()
    tiago.go_to = lambda loc: True  # Make movement always succeed

    # Set TIAGo to be in the delivery phase
    tiago.status = 'occupied'
    tiago.dish = 'TestDish'
    tiago.target_table = 1
    tiago.order_phase = 4  # Client verification phase after delivery

    # Replace OrderVerificationSystem and SpeechInterface
    ov = OrderVerificationSystem(tiago)
    si = SpeechInterface()
    si.tiago = tiago
    si.serving_sentences = lambda: 'empty_plates'  # Simulate client requesting empty plates
    ov.speech_interface = si
    tiago.order_verificatiion_system = ov

    # Call operation() for a single iteration
    tiago.operation()

    # After receiving 'empty_plates', TIAGo should switch to clearing flow
    assert tiago.dish == 'clearing'
    assert tiago.order_phase == 1


# Integration Test: TIAGo.go_to uses NavigationSystem and updates internal positions
# test_tiago_navigation_integration
def test_tiago_navigation_integration():
    """
    Verify that TIAGo.go_to uses NavigationSystem.navigate_to and updates positions accordingly.
    """
    rospy.init_node = lambda *args, **kwargs: None

    tiago = TIAGo()

    # Patch navigate_to to record calls
    calls = []
    def fake_navigate_to(pos):
        calls.append(pos)
        return True
    tiago.navigation_system.navigate_to = fake_navigate_to

    # Define a test location: center should be at (center_x, center_y)
    width, height = 2.0, 4.0
    center_x, center_y = 7.5, 12.5
    location = [center_x - width/2, center_y - height/2, width, height]

    success = tiago.go_to(location)
    assert success, "TIAGo.go_to should return True when navigation_system.navigate_to succeeds"

    # navigate_to called with expected center coordinates
    assert calls == [[center_x, center_y]], "NavigationSystem.navigate_to was not called with correct target"

    # TIAGo.x and y updated to target center
    assert pytest.approx(tiago.x, rel=1e-3) == center_x
    assert pytest.approx(tiago.y, rel=1e-3) == center_y

    # SLAM robot_pose updated accordingly
    rx, ry, _ = tiago.navigation_system.slam.robot_pose
    assert pytest.approx(rx, rel=1e-3) == center_x
    assert pytest.approx(ry, rel=1e-3) == center_y


# Integration Test: OrderVerificationSystem invokes PerceptionSystem for grasping and placement checks
# test_orderverification_perception_integration
def test_orderverification_perception_integration():
    """
    Verify that OrderVerificationSystem invokes PerceptionSystem for both grasping and placement checks.
    """
    # Create dummy TIAGo and stub perception system
    class DummyTiago: pass
    tiago = DummyTiago()
    tiago.perception_system = type('StubPerception', (), {})()
    calls = []
    def fake_verify(mode):
        calls.append(mode)
        # Fail grasping, succeed placement
        return False if mode == 'grasping' else True
    tiago.perception_system.verification_of_grasping_and_placement = fake_verify

    # Initialize OrderVerificationSystem with stubbed TIAGo
    ov = OrderVerificationSystem(tiago)
    # Stub speech_interface to isolate perception test
    ov.speech_interface.serving_sentences = lambda: 'client_issue'

    # Test verify_served_order triggers grasping check and returns error on failure
    error = ov.verify_served_order('dummy_dish')
    assert calls == ['grasping']
    assert error == 'grasping_problem'

    # Reset calls and test verify_delivery_client triggers placement check
    calls.clear()
    result = ov.verify_delivery_client()
    # first element is not success (placement True -> False), second is speech output
    assert calls == ['placement']
    assert result == [False, 'client_issue']


# Integration Test: OrderVerification and ReasoningSystem coordination
# test_orderverification_reasoning_integration
def test_orderverification_reasoning_integration():
    """
    Verify that ReasoningSystem can plan a placement and OrderVerificationSystem can verify it without errors.
    """
    # Stub TIAGo with perception that always succeeds (for grasping/placement)
    class DummyTiago: pass
    tiago = DummyTiago()
    tiago.perception_system = type('P', (), {})()
    tiago.perception_system.verification_of_grasping_and_placement = lambda mode: True

    # Initialize OrderVerificationSystem with stubbed TIAGo
    ov = OrderVerificationSystem(tiago)
    # Stub speech to no complaint
    ov.speech_interface.serving_sentences = lambda: None

    # ReasoningSystem without TIAGo to plan placement
    rs = ReasoningSystem()
    # Provide empty perception_data so free areas exist
    target = rs.reason_about_placement(perception_data=[], dish_dimensions={'width':0.1,'length':0.1})

    # Should return a valid coordinate
    assert isinstance(target, list) and len(target) == 2

    # Simulate verification of a served order (grasp) and delivery (placement)
    assert ov.verify_served_order('dummy') is None
    placement_result = ov.verify_delivery_client()
    # placement successful (False), no client problem (None)
    assert placement_result == [False, None]


# Integration Test: NavigationSystem and ManipulationSystem end-to-end workflow
# test_navigation_manipulation_integration
def test_navigation_manipulation_integration():
    """
    Verify that NavigationSystem and ManipulationSystem coordinate correctly:
    - TIAGo.go_to uses navigation_system
    - ManipulationSystem.execute_manipulation completes manipulation
    """
    # prevent rospy.init_node collisions in tests
    rospy.init_node = lambda *args, **kwargs: None
    # stub out rospy.sleep so manipulation doesn't slow the test
    rospy.sleep = lambda duration: None

    tiago = TIAGo()

    # ensure the subsystems exist on the TIAGo instance
    # (in case TIAGo.__init__ didn't already create them)
    tiago.navigation_system = NavigationSystem(tiago)
    tiago.manipulation_system = ManipulationSystem(tiago)

    # Patch navigation_system.navigate_to to record calls and succeed
    nav_calls = []
    tiago.navigation_system.navigate_to = lambda pos: nav_calls.append(pos) or True

    # First, test navigation to service area
    service = tiago.service_area_coords  # [x, y, width, height]
    success_nav = tiago.go_to(service)
    assert success_nav, "Navigation should succeed"
    # Center of service area is (x+width/2, y+height/2)
    center = [service[0] + service[2]/2, service[1] + service[3]/2]
    assert nav_calls == [center], "NavigationSystem.navigate_to should be called with service area center"

    # Then test manipulation at a sample target position
    ms = tiago.manipulation_system
    target_position = [center[0] + 0.5, center[1] + 0.5, 0.2]
    success_manip = ms.execute_manipulation(target_position)
    assert success_manip, "Manipulation should complete successfully"
    assert ms.manipulation_supervisor.manipulation_status == 'completed', "ManipulationSupervisor should report completed"


# Integration Test: NavigationSystem SLAM processes perception messages and updates occupancy grid
# test_navigation_perception_integration
def test_navigation_perception_integration():
    """
    Verify that NavigationSystem's SLAM processes perception object_detection messages
    and updates the occupancy grid.
    """
    # Initialize NavigationSystem (singleton resets on first call)
    nav = NavigationSystem()
    slam = nav.slam

    # Choose a world coordinate and corresponding map cell
    x_world, y_world = 1.2, 2.4
    mx, my = slam.map.world_to_map(x_world, y_world)
    # Initially cell should be free (0)
    assert slam.map.get_cell(mx, my) == 0

    # Simulate perception publishing an object detection at the world coordinate
    detection_msg = String(data=f"object,{x_world},{y_world}")
    slam.process_object_detection(detection_msg)

    # After processing, the map cell must be marked occupied (100)
    assert slam.map.get_cell(mx, my) == 100


# Integration Test: ReasoningController placement planning with free areas
# test_perception_reasoning_integration
def test_perception_reasoning_integration():
    """
    Verify that ReasoningController uses perception data to plan placement correctly.
    """
    # Initialize controller without TIAGo to avoid ROS publishers
    controller = ReasoningController(None)

    # Provide perception data with two small objects on the table
    perception_data = [
        {"type": "plate", "position": [0.2, 0.2], "dimensions": [0.1, 0.1]},
        {"type": "cup",   "position": [0.6, 0.8], "dimensions": [0.1, 0.1]},
    ]

    # Request placement reasoning
    target = controller.process_placement_request(perception_data)
    # Should return a valid coordinate
    assert isinstance(target, list) and len(target) == 2

    # Extract occupied areas from last analysis
    layout = controller.table_analyzer.analyze_table(perception_data)
    # Ensure target is not within any occupied area
    for area in layout['occupied_areas']:
        x_ok = not (area['x_min'] <= target[0] <= area['x_max'])
        y_ok = not (area['y_min'] <= target[1] <= area['y_max'])
        assert x_ok or y_ok, "Target overlaps occupied area"


# Integration Test: ReasoningController returns None when no free space
# test_perception_reasoning_no_space
def test_perception_reasoning_no_space():
    """
    Verify that ReasoningController returns None when no free space is available.
    """
    controller = ReasoningController(None)
    # Create one large object covering the entire table
    dims = controller.table_analyzer.table_dimensions
    perception_data = [
        {"type": "full", "position": [dims['width']/2, dims['length']/2],
         "dimensions": [dims['width'], dims['length']]}
    ]

    target = controller.process_placement_request(perception_data)
    assert target is None, "Should return None when table has no free space"


# Integration Test: ManipulationSystem receives perception_data and invokes callback without altering status
# test_perception_manipulation_integration
def test_perception_manipulation_integration():
    """
    Verify that ManipulationSystem receives perception_data messages from PerceptionSystem
    and invoke the receive_perception_data callback without altering manipulation status.
    """
    # Initialize systems without TIAGo to avoid ROS publishers
    manipulation_system = ManipulationSystem(None)
    supervisor = manipulation_system.manipulation_supervisor

    # Stub the receive_perception_data to record calls and track status
    received = []
    def record_callback(msg):
        received.append(msg.data)
    supervisor.receive_perception_data = record_callback

    # Simulate perception publishing data
    test_data = "object,1.5,2.5"
    supervisor.receive_perception_data(String(data=test_data))

    # Callback should have been invoked with correct data
    assert received == [test_data]


# Integration Test: ReasoningSystem generates placement target and ManipulationSystem executes it successfully
# test_reasoning_manipulation_integration
def test_reasoning_manipulation_integration():
    """
    Verify that ReasoningSystem generates a placement target and ManipulationSystem executes manipulation at that target.
    """
    # Prevent ROS node reinitialization and speed up sleeps
    rospy.init_node = lambda *args, **kwargs: None
    rospy.sleep = lambda duration: None

    # Generate a placement target from reasoning
    rs = ReasoningSystem(None)
    target = rs.reason_about_placement(perception_data=[], dish_dimensions={'width': 0.1, 'length': 0.1})
    assert isinstance(target, list) and len(target) == 2, "ReasoningSystem did not return a valid target"

    # Execute manipulation at the target position (with table height z)
    ms = ManipulationSystem(None)
    success = ms.execute_manipulation([target[0], target[1], 0.7])
    assert success, "ManipulationSystem failed to complete the manipulation"
    assert ms.manipulation_supervisor.manipulation_status == 'completed', "ManipulationSupervisor should report completed"


# Integration Test: End-to-End Service Workflow with KPI measurement
def test_end_to_end_service_workflow():
    """
    End-to-end test of the full service workflow from POS to TIAGo operation.
    Measures multiple KPIs for validation.
    """
    # Skip ROS initialization and delay to speed up testing
    rospy.init_node = lambda *args, **kwargs: None
    rospy.sleep     = lambda t: None

    # Initialize OrchestrationManager and clear all state
    om = OrchestrationManager()
    om.orderQueue.clear()
    om.error_messages.clear()
    om.dictTIAGoAvailable.clear()
    om.dictTIAGoPosition.clear()

    # Initialize counters for orders and KPI tracking
    orders_sent = 0
    orders_received = 0
    orders_processed = 0

    # Hook order_storing to count received and processed orders
    orig_store = om.order_storing
    def counting_order_storing(msg):
        nonlocal orders_received, orders_processed
        orders_received += 1
        result = orig_store(msg)
        # Increment processed counter if order processed successfully
        orders_processed += 1
        return result
    om.order_storing = counting_order_storing

    # Setup TIAGo instance and redirect updates to OrchestrationManager
    tiago = TIAGo()
    avail_sent = 0
    pos_sent   = 0
    def count_avail(data):
        nonlocal avail_sent
        avail_sent += 1
        return om.manage_availability(String(data=data))
    def count_pos(msg):
        nonlocal pos_sent
        pos_sent += 1
        return om.manage_position(msg)

    tiago.publisher_availability = type('',(),{'publish':lambda self,d: count_avail(d)})()
    tiago.publisher_position     = type('',(),{'publish':lambda self,m: count_pos(m)})()
    tiago.publisher_clearing_order = type('',(),{'publish':lambda self,d: None})()

    # Start timing the workflow execution
    start = time.time()

    # Emit one order from POS to OrchestrationManager
    class DummyPOS(POSModule):
        def __init__(self):
            super().__init__()
            self.publisher = type('',(),{
                'publish': lambda self,raw: om.order_storing(String(data=raw))
            })()
    pos = DummyPOS()
    # Force emission of only one order
    with patch.object(random,'randint',return_value=1):
        orders_sent += 1
        pos.order_emission(nb_loops=0)

    # Publish TIAGo availability and position to OM
    tiago.send_availability()
    tiago.send_position()

    # Assign the order to TIAGo
    om.publisher_order = type('',(),{
        'publish': lambda self, msg: tiago.manage_order_request(String(data=msg))
    })()
    om.assign_order()

    # Force all TIAGo service steps to succeed
    tiago.perception_system.perception = lambda: True
    tiago.navigation_system.navigate_to = lambda loc: True
    tiago.order_verificatiion_system.verify_delivery_client = lambda: (False,None)

    # Loop until TIAGo returns to available state
    while tiago.status != 'available':
        tiago.operation()

    elapsed = time.time() - start

    # Evaluate KPIs
    # 1. Workflow latency
    assert elapsed <= 5.0, f"Workflow too slow: {elapsed:.2f}s"

    # 2. POS to OM order delivery rate
    assert orders_received == orders_sent == 1

    # 3. Correct order processing rate
    assert orders_processed == orders_received

    # 4. Availability update delivery and processing rate
    assert len(om.dictTIAGoAvailable) == 1, f"Expected 1 TIAGo in availability dict, got {len(om.dictTIAGoAvailable)}"
    assert avail_sent >= 1,                 f"Expected at least 1 availability publish, got {avail_sent}"

    # 5. Position update delivery and processing rate
    assert len(om.dictTIAGoPosition) == 1, f"Expected 1 position entry, got {len(om.dictTIAGoPosition)}"
    assert pos_sent >= 1,                     f"Expected at least 1 position publish, got {pos_sent}"

    # 6. Distance computation correctness
    # Prepare dummy robot position at (3,4) for robot ID 1
    om.dictTIAGoPosition[1] = [3, 4]
    d = om.compute_distance(1)
    assert abs(d - 5.0) < 1e-6

    # 7. Idle-coefficient: no TIAGo idle while orders remain
    idle_coef = min(
        sum(1 for st in om.dictTIAGoAvailable.values() if st=='available'),
        len(om.orderQueue)
    )
    assert idle_coef == 0

    # Final state assertions
    assert tiago.status == 'available'
    assert not om.orderQueue



# Run tests only if this module is executed directly
if __name__ == '__main__':
    pytest.main()
